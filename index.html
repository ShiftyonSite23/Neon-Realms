<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Neon Realms — Levels 1–14</title>
<style>
  html,body{height:100%;margin:0;background:#0a0a12;color:#e8f0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  #hud{position:fixed;left:8px;top:8px;z-index:11;background:#101022;border:1px solid #2b2b64;border-radius:10px;padding:8px 10px;font-size:12px;opacity:.96;min-width:220px;display:none}
  #hud .row{display:flex;justify-content:space-between;gap:10px;align-items:center}

  /* Touch buttons — ALL 80×80 */
  #buttons{position:fixed;left:12px;bottom:16px;display:none;gap:10px;z-index:10}
  .btn,#dashBtn{width:80px;height:80px;border-radius:16px;border:1px solid #2b2b64;background:radial-gradient(100% 100% at 50% 0%,#1a1a36 0%,#0e0e1f 100%);color:#bfe2ff;font-weight:800;font-size:12px}
  #dashBtn{position:fixed;right:12px;bottom:88px;z-index:10;display:none}
  #jumpBtn{position:fixed;right:12px;bottom:16px}

  /* Overlay (level complete) */
  #overlay{position:fixed;inset:0;display:none;z-index:20;align-items:center;justify-content:center;background:rgba(8,8,16,.55)}
  #overlay .card{background:#0d0d1fdd;border:1px solid #63d7ff;color:#e8f0ff;padding:16px 22px;border-radius:14px;text-align:center;min-width:320px}
  #overlay h2{margin:0 0 8px 0;font-size:22px}
  #overlay p{margin:6px 0;font-size:14px;color:#bfe2ff}
  #overlay .score{font-size:28px;margin-top:8px}
  #overlay .btnbar{margin-top:12px;display:flex;gap:10px;justify-content:center}
  #overlay button{width:80px;height:80px;border-radius:16px;border:1px solid #2b2b64;background:radial-gradient(100% 100% at 50% 0%,#1a1a36 0%,#0e0e1f 100%);color:#bfe2ff;font-weight:800;font-size:12px}

  /* ===== Start Menu ===== */
  #menu{position:fixed;inset:0;z-index:30;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#070711 0%,#0c0c18 100%)}
  .menu-wrap{display:flex;flex-direction:column;align-items:center;gap:18px;text-align:center;padding:24px}
  .logo{font-weight:900;font-size:64px;letter-spacing:6px;line-height:1;margin:0 0 4px}
  .logo .n1{color:#ff49c3;text-shadow:0 0 12px #ff49c3, 0 0 28px #ff49c3}
  .logo .n2{color:#38d9ff;text-shadow:0 0 12px #38d9ff, 0 0 28px #38d9ff}
  .subtitle{color:#bfe2ff;opacity:.9;margin-top:2px}
  .menu{display:flex;flex-direction:column;gap:10px;margin-top:10px}
  .m-btn{min-width:240px;height:56px;border-radius:14px;border:1px solid #2b2b64;background:radial-gradient(100% 100% at 50% 0%,#1a1a36 0%,#0e0e1f 100%);color:#c9f3ff;font-weight:800;font-size:16px}
  .row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
  .small{height:44px;min-width:160px;font-size:14px}

  /* Panels */
  .panel{display:none;background:#0d0d1fdd;border:1px solid #63d7ff;color:#e8f0ff;padding:16px;border-radius:14px;min-width:320px;max-width:92vw}
  .panel h3{margin:0 0 10px 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(64px,1fr));gap:8px;max-width:560px}
  .chip{border:1px solid #2b2b64;border-radius:12px;padding:8px 0;text-align:center;background:#14142a;font-weight:800}
  .chip.sel{outline:2px solid #63d7ff}

  /* Rotate overlay for portrait (mobile) */
  #rotate{position:fixed;inset:0;z-index:40;display:none;align-items:center;justify-content:center;background:#0a0a12ee}
  #rotate .card{background:#0d0d1fee;border:1px solid #63d7ff;color:#e8f0ff;padding:16px 22px;border-radius:14px;text-align:center;max-width:320px}
  @media (orientation:portrait){
    #rotate{display:flex}
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- ===== HUD / Touch ===== -->
<div id="hud">
  <div class="row"><span id="levelLbl">Level 1/14</span><span id="dashLbl">Dash: READY</span></div>
  <div class="row"><span id="deathLbl">Deaths: 0</span><span id="timerLbl">Time: 0.00</span></div>
</div>

<div id="buttons">
  <button class="btn" id="leftBtn">LEFT</button>
  <button class="btn" id="rightBtn">RIGHT</button>
  <button class="btn" id="jumpBtn">JUMP</button>
</div>
<button id="dashBtn">DASH</button>

<!-- ===== Level Complete Overlay ===== -->
<div id="overlay">
  <div class="card">
    <h2 id="ovTitle">Level Complete!</h2>
    <p id="ovBody"></p>
    <div class="score" id="ovScore"></div>
    <div class="btnbar">
      <button id="nextBtn">Next</button>
      <button id="retryBtn">Retry</button>
    </div>
  </div>
</div>

<!-- ===== START MENU ===== -->
<div id="menu">
  <div class="menu-wrap">
    <div class="logo"><span class="n1">NEON</span> <span class="n2">REALMS</span></div>
    <div class="subtitle">v0.1 — Tap Start to Jack In</div>
    <div class="menu">
      <button class="m-btn" id="startBtn">START</button>
      <div class="row">
        <button class="m-btn small" id="levelsBtn">LEVEL SELECT</button>
        <button class="m-btn small" id="settingsBtn">SETTINGS</button>
        <button class="m-btn small" id="creditsBtn">CREDITS</button>
      </div>
    </div>

    <!-- Panels -->
    <div class="panel" id="levelsPanel">
      <h3>Select Level</h3>
      <div class="grid" id="levelGrid"></div>
      <div class="row" style="margin-top:10px">
        <button class="m-btn small" data-close="levelsPanel">Close</button>
      </div>
    </div>

    <div class="panel" id="settingsPanel">
      <h3>Settings</h3>
      <div class="row">
        <button class="m-btn small" id="touchToggle">Touch Controls: ON</button>
        <button class="m-btn small" id="speedToggle">Camera Lookahead: MED</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="m-btn small" data-close="settingsPanel">Close</button>
      </div>
    </div>

    <div class="panel" id="creditsPanel">
      <h3>Credits</h3>
      <p style="color:#bfe2ff;max-width:520px">
        Neon Realms prototype. Code, levels, lasers, and questionable OSHA compliance by the team.
      </p>
      <div class="row" style="margin-top:10px">
        <button class="m-btn small" data-close="creditsPanel">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Portrait rotate prompt -->
<div id="rotate">
  <div class="card">
    <h2>Rotate Device</h2>
    <p>Neon Realms plays best in <b>landscape</b>. Please rotate your phone.</p>
  </div>
</div>

<script>
(() => {
  /* =================== EXISTING GAME CODE (shortened comments only) =================== */
  const DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d',{alpha:false});
  const resize=()=>{canvas.width=Math.floor(innerWidth*DPR);canvas.height=Math.floor(innerHeight*DPR);};
  addEventListener('resize',resize); resize();

  const hud=document.getElementById('hud');
  const levelLbl=document.getElementById('levelLbl');
  const dashLbl=document.getElementById('dashLbl');
  const timerLbl=document.getElementById('timerLbl');
  const deathLbl=document.getElementById('deathLbl');
  const overlay=document.getElementById('overlay');
  const ovTitle=document.getElementById('ovTitle');
  const ovBody=document.getElementById('ovBody');
  const nextBtn=document.getElementById('nextBtn');
  const retryBtn=document.getElementById('retryBtn');

  const keys={left:false,right:false,jump:false};
  let jumpEdge=false,lastJumpTapMs=-1;
  const setKey=(k,v)=>keys[k]=v;
  const tapJump=()=>{jumpEdge=true;lastJumpTapMs=performance.now();};
  function bindHold(el,key){
    el.addEventListener('pointerdown',e=>{e.preventDefault();setKey(key,true);if(key==='jump')tapJump();},{passive:false});
    el.addEventListener('pointerup',e=>{e.preventDefault();setKey(key,false);},{passive:false});
    el.addEventListener('touchstart',e=>{e.preventDefault();setKey(key,true);if(key==='jump')tapJump();},{passive:false});
    el.addEventListener('touchend',e=>{e.preventDefault();setKey(key,false);},{passive:false});
  }
  bindHold(document.getElementById('leftBtn'),'left');
  bindHold(document.getElementById('rightBtn'),'right');
  bindHold(document.getElementById('jumpBtn'),'jump');
  document.getElementById('dashBtn').addEventListener('pointerup',e=>{e.preventDefault();tryDash(player.facing||1);});
  addEventListener('keydown',e=>{if(e.repeat)return;
    if(e.code==='ArrowLeft'||e.code==='KeyA')setKey('left',true);
    if(e.code==='ArrowRight'||e.code==='KeyD')setKey('right',true);
    if(e.code==='Space'||e.code==='KeyW'||e.code==='ArrowUp'){setKey('jump',true);tapJump();}
    if(e.code==='ShiftLeft'||e.code==='ShiftRight')tryDash(player.facing||1);
    if(e.code==='Escape') toggleMenu(true);
  });
  addEventListener('keyup',e=>{
    if(e.code==='ArrowLeft'||e.code==='KeyA')setKey('left',false);
    if(e.code==='ArrowRight'||e.code==='KeyD')setKey('right',false);
    if(e.code==='Space'||e.code==='KeyW'||e.code==='ArrowUp')setKey('jump',false);
  });

  const groundY=520;
  const rect=(x,y,w,h)=>({t:'rect',x,y,w,h});
  const slope=(x1,y1,x2,y2)=>({t:'slope',x1,y1,x2,y2,minX:Math.min(x1,x2),maxX:Math.max(x1,x2)});
  const slopeYAt=(s,x)=>{const t=(x-s.x1)/(s.x2-s.x1);return s.y1+t*(s.y2-s.y1);};
  const spike=(x,y,w,h)=>({t:'spike',x,y,w,h});
  const laser=(x,y,w,h,axis='y',amp=0,speed=0)=>({t:'laser',x,y,w,h,axis,amp,speed,phase:Math.random()*Math.PI*2});
  const drone=(x,y,minX,maxX,speed)=>({t:'drone',x,y,w:36,h:24,minX,maxX,dir:1,speed});
  const hover=(x,y,minY,maxY,speed)=>({t:'hover',x,y,w:34,h:22,minY,maxY,dir:1,speed});
  const goal=(x,y)=>({t:'goal',x,y,w:36,h:120});
  const mplat=(x,y,w,h,axis,min,max,speed,pause=0.2)=>({t:'mplat',x,y,w,h,axis,min,max,speed,dir:1,pause,waiting:0,prevX:x,prevY:y});
  const crumble=(x,y,w,h,breakDelay=0.5,resetAfter=2.5)=>({t:'crumble',x,y,w,h,breakDelay,resetAfter,active:true,timer:0,resetting:0,stepping:false});

  /* ===== Levels 1–14 (unchanged from your code) ===== */
  /*  ——— SNIP: keep all your buildLevel1..buildLevel14 functions exactly as in your file ——— */
  /* For brevity in this message, assume they are here, unchanged. Paste yours in. */

  // === PLACE YOUR ORIGINAL LEVEL BUILDERS HERE ===

  // ======= Level list =======
  const LEVELS=[
    buildLevel1(),buildLevel2(),buildLevel3(),buildLevel4(),
    buildLevel5(),buildLevel6(),buildLevel7(),buildLevel8(),buildLevel9(),buildLevel10(),
    buildLevel11(),buildLevel12(),buildLevel13(),buildLevel14()
  ];
  let levelIndex=0; const currentL=()=>LEVELS[levelIndex];

  // ===== Player / Physics =====
  const player={x:120,y:420,w:30,h:36,vx:0,vy:0,onGround:false,facing:1};
  const MOVE=360,G=2200,JUMP=780; let coyote=0;
  const DASH_SPEED=1700,DASH_COOLDOWN=0.85, DJ_MIN=0.06, DJ_MAX=0.30, DJ_BOOST=300;
  let dashCooldown=0,dashStartMs=-1,djDone=false;
  let camX=0,camY=groundY-120,lookAhead=0,last=performance.now();

  function tryDash(dir){ if(dashCooldown>0)return; player.vx=dir*DASH_SPEED; dashCooldown=DASH_COOLDOWN; dashStartMs=performance.now(); djDone=false; }

  let run={deaths:0,timeStart:performance.now()};
  function respawn(start=false,death=false){
    player.x=120;player.y=420;player.vx=0;player.vy=0;player.onGround=false;coyote=0;
    if(death){run.deaths++;deathLbl.textContent='Deaths: '+run.deaths;}
    if(start){camX=player.x;camY=groundY-120;}
  }
  function startLevel(i){
    levelIndex=Math.max(0,Math.min(LEVELS.length-1,i));
    levelLbl.textContent=`Level ${levelIndex+1}/${LEVELS.length}`;
    respawn(true);
    run.deaths=0; run.timeStart=performance.now();
    deathLbl.textContent='Deaths: 0';
  }

  /* =================== NEW: MENU STATE =================== */
  const menu=document.getElementById('menu');
  const startBtn=document.getElementById('startBtn');
  const levelsBtn=document.getElementById('levelsBtn');
  const settingsBtn=document.getElementById('settingsBtn');
  const creditsBtn=document.getElementById('creditsBtn');
  const levelGrid=document.getElementById('levelGrid');
  const levelsPanel=document.getElementById('levelsPanel');
  const settingsPanel=document.getElementById('settingsPanel');
  const creditsPanel=document.getElementById('creditsPanel');
  const touchToggle=document.getElementById('touchToggle');
  const speedToggle=document.getElementById('speedToggle');

  let gameRunning=false;
  let touchOn=true;
  let lookaheadMode=1; // 0=LOW,1=MED,2=HIGH

  function applyUIVisibility(){
    hud.style.display = gameRunning ? 'block' : 'none';
    document.getElementById('buttons').style.display = (gameRunning && touchOn) ? 'flex' : 'none';
    document.getElementById('dashBtn').style.display = (gameRunning && touchOn) ? 'block' : 'none';
  }

  function toggleMenu(show){
    if(show){
      gameRunning=false;
      menu.style.display='flex';
      applyUIVisibility();
    }else{
      menu.style.display='none';
      gameRunning=true;
      applyUIVisibility();
      // (Re)start current level if first boot
      if(!hasBooted){startLevel(levelIndex); hasBooted=true;}
    }
  }
  let hasBooted=false;

  // Buttons
  startBtn.onclick=()=>{ hidePanels(); toggleMenu(false); };
  levelsBtn.onclick=()=>{ showPanel('levelsPanel'); };
  settingsBtn.onclick=()=>{ showPanel('settingsPanel'); };
  creditsBtn.onclick=()=>{ showPanel('creditsPanel'); };

  function showPanel(id){ hidePanels(); document.getElementById(id).style.display='block'; }
  function hidePanels(){ [levelsPanel,settingsPanel,creditsPanel].forEach(p=>p.style.display='none'); }
  document.querySelectorAll('[data-close]').forEach(btn=>{
    btn.addEventListener('click',()=>{ document.getElementById(btn.dataset.close).style.display='none'; });
  });

  // Build Level Grid
  for(let i=0;i<LEVELS.length;i++){
    const b=document.createElement('button');
    b.className='chip';
    b.textContent=String(i+1);
    b.onclick=()=>{ levelIndex=i; startLevel(levelIndex); hidePanels(); toggleMenu(false); };
    levelGrid.appendChild(b);
  }

  // Settings toggles
  function updateSettingsLabels(){
    touchToggle.textContent = `Touch Controls: ${touchOn?'ON':'OFF'}`;
    speedToggle.textContent = `Camera Lookahead: ${['LOW','MED','HIGH'][lookaheadMode]}`;
  }
  touchToggle.onclick=()=>{ touchOn=!touchOn; updateSettingsLabels(); applyUIVisibility(); };
  speedToggle.onclick=()=>{ lookaheadMode=(lookaheadMode+1)%3; updateSettingsLabels(); };

  updateSettingsLabels();
  toggleMenu(true); // start on menu

  /* =================== GAME LOOP =================== */
  function updateHazards(dt,hz){for(const h of hz){if(h.t==='laser'){const t=performance.now()/1000+(h.phase||0);h.offset=Math.sin(t*h.speed)*h.amp;}}}
  function updateEnemies(dt,en){
    for(const e of en){
      if(e.t==='drone'){e.x+=e.dir*e.speed*dt; if(e.x<e.minX){e.x=e.minX;e.dir=1;} if(e.x+e.w>e.maxX){e.x=e.maxX-e.w;e.dir=-1;}}
      else if(e.t==='hover'){e.y+=e.dir*e.speed*dt; if(e.y<e.minY){e.y=e.minY;e.dir=1;} if(e.y+e.h>e.maxY){e.y=e.maxY-e.h;e.dir=-1;}}
    }
  }
  function updatePlats(dt,plats){
    for(const p of plats){
      p.prevX=p.x; p.prevY=p.y;
      if(p.waiting>0){p.waiting-=dt;continue;}
      if(p.axis==='x'){p.x+=p.dir*p.speed*dt; if(p.x<p.min){p.x=p.min;p.dir=1;p.waiting=p.pause;} if(p.x>p.max){p.x=p.max;p.dir=-1;p.waiting=p.pause;}}
      else{p.y+=p.dir*p.speed*dt; if(p.y<p.min){p.y=p.min;p.dir=1;p.waiting=p.pause;} if(p.y>p.max){p.y=p.max;p.dir=-1;p.waiting=p.pause;}}
    }
  }
  function updateCrumbles(dt,pads,player){
    for(const p of pads){if(p.t==='crumble') p.stepping=false;}
    const meFeet={x:player.x,y:player.y+player.h-1,w:player.w,h:2};
    const ov=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
    for(const c of pads){
      if(c.t!=='crumble'||!c.active)continue;
      const top={x:c.x,y:c.y-2,w:c.w,h:6};
      if(ov(meFeet,top)&&player.vy>=0) c.stepping=true;
    }
    for(const c of pads){
      if(c.t!=='crumble')continue;
      if(c.active){
        if(c.stepping){ c.timer+=dt; if(c.timer>=c.breakDelay){ c.active=false; c.timer=0; c.resetting=c.resetAfter; } }
        else{ c.timer=Math.max(0,c.timer-dt*0.5); }
      }else{
        c.resetting-=dt; if(c.resetting<=0){ c.active=true; c.resetting=0; c.timer=0; }
      }
    }
  }

  function step(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;

    // If menu is open, render a subtle animated background and bail
    if(!gameRunning){
      renderMenuBackground(now);
      requestAnimationFrame(step);
      return;
    }

    // HUD
    timerLbl.textContent='Time: '+((now-run.timeStart)/1000).toFixed(2);
    dashCooldown=Math.max(0,dashCooldown-dt);
    dashLbl.textContent='Dash: '+(dashCooldown>0?dashCooldown.toFixed(1)+'s':'READY');

    // Input → motion
    const dir=(keys.right?1:0)-(keys.left?0?0:0);
    const _dir=(keys.right?1:0)-(keys.left?1:0);
    const useDir=isNaN(dir)?_dir:dir;
    if(useDir!==0) player.facing=useDir;
    // Camera lookahead strength from settings
    const lookFactor=[0.18,0.30,0.42][lookaheadMode];

    player.vx+=(useDir*360-player.vx)*0.30; player.vy+=2200*dt;
    if(player.onGround) coyote=0.12; else coyote=Math.max(0,coyote-dt);
    if(jumpEdge&&(player.onGround||coyote>0)){player.vy=-780;coyote=0;} jumpEdge=false;

    const djDelta=(lastJumpTapMs>0&&dashStartMs>0)?(lastJumpTapMs-dashStartMs):-1e9;
    if(!djDone && djDelta>=0.06*1000 && djDelta<=0.30*1000){ player.vy=Math.min(player.vy,0)-300; djDone=true; }

    const L=currentL();
    updateHazards(dt,L.hz); updateEnemies(dt,L.en); updatePlats(dt,L.plats||[]); updateCrumbles(dt,L.pads||[],player);

    let nx=player.x+player.vx*dt, ny=player.y+player.vy*dt;

    // Collisions (same as your code)
    let grounded=false; const boxY={x:nx,y:ny,w:player.w,h:player.h};
    for(const p of L.pads){
      const solid=(p.t==='rect')||(p.t==='crumble'&&p.active);
      if(!solid)continue;
      if(!(boxY.x<p.x+p.w&&boxY.x+boxY.w>p.x&&boxY.y<p.y+p.h&&boxY.y+boxY.h>p.y))continue;
      if(player.vy>0){ ny=p.y-player.h; player.vy=0; grounded=true; }
      else if(player.vy<0){ ny=p.y+p.h; player.vy=0; }
      boxY.y=ny;
    }
    const feetX=nx+player.w*0.5;
    for(const s of L.pads){ if(s.t!=='slope')continue; if(feetX<s.minX||feetX>s.maxX)continue;
      const yS=slopeYAt(s,feetX); if(ny+player.h>=yS-0.5&&player.vy>=0){ ny=yS-player.h; player.vy=0; grounded=true; } }
    for(const m of (L.plats||[])){
      const top={x:m.x,y:m.y-2,w:m.w,h:6}, pxTop={x:nx,y:ny+player.h-2,w:player.w,h:4};
      const overTop=(pxTop.x<top.x+top.w&&pxTop.x+pxTop.w>top.x&&pxTop.y<top.y+top.h&&pxTop.y+pxTop.h>top.y);
      if(overTop&&player.vy>=0){ ny=m.y-player.h; player.vy=0; grounded=true; nx+=(m.x-m.prevX); ny+=(m.y-m.prevY); }
      const pb={x:m.x,y:m.y,w:m.w,h:m.h}, me={x:nx,y:ny,w:player.w,h:player.h};
      const ov=!(me.x>pb.x+pb.w||me.x+me.w<pb.x||me.y>pb.y+pb.h||me.y+me.h<pb.y);
      if(ov){ const dxL=me.x+me.w-pb.x,dxR=pb.x+pb.w-me.x,dyT=me.y+me.h-pb.y,dyB=pb.y+pb.h-me.y;
        if(Math.min(dxL,dxR)<Math.min(dyT,dyB)){ if(dxL<dxR)nx-=dxL; else nx+=dxR; player.vx=0; }
        else{ if(dyT<dyB){ ny-=dyT; player.vy=0; grounded=true; } else { ny+=dyB; player.vy=0; } } }
    }
    const boxX={x:nx,y:ny,w:player.w,h:player.h};
    for(const p of L.pads){ if(p.t!=='rect')continue;
      if(!(boxX.x<p.x+p.w&&boxX.x+boxX.w>p.x&&boxX.y<p.y+p.h&&boxX.y+p.h>p.y))continue;
      if(player.vx>0){ nx=p.x-player.w; player.vx=0; } else if(player.vx<0){ nx=p.x+p.w; player.vx=0; }
      boxX.x=nx;
    }
    player.x=nx; player.y=ny; player.onGround=grounded;

    // Hazards + enemies
    const me={x:player.x,y:player.y,w:player.w,h:player.h};
    const hit=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
    let died=false;
    for(const h of L.hz){
      if(h.t==='spike'){const hb={x:h.x,y:h.y-h.h,w:h.w,h:h.h}; if(hit(me,hb)){died=true;break;}}
      else if(h.t==='laser'){const hb={x:(h.axis==='x'?(h.x+(h.offset||0)):h.x),y:(h.axis==='y'?(h.y+(h.offset||0)):h.y),w:h.w,h:h.h}; if(hit(me,hb)){died=true;break;}}
    }
    if(!died){ for(const e of L.en){ if(hit(me,e)){died=true;break;} } }
    if(died){ respawn(false,true); }

    // Goal
    const g=L.goal;
    if(hit(me,g)){
      const sec=(performance.now()-run.timeStart)/1000;
      overlay.style.display='flex';
      ovTitle.textContent=(levelIndex===LEVELS.length-1)?'Run Complete!':`Level ${levelIndex+1} Complete!`;
      ovBody.textContent=`Time: ${sec.toFixed(2)}s • Deaths: ${run.deaths}`;
      nextBtn.onclick=()=>{overlay.style.display='none'; if(levelIndex<LEVELS.length-1) startLevel(++levelIndex); else {toggleMenu(true);} };
      retryBtn.onclick=()=>{overlay.style.display='none'; startLevel(levelIndex);};
      requestAnimationFrame(step);
      return;
    }

    if(player.y>groundY+900) respawn(false,true);

    // Camera (look-ahead uses setting)
    const viewW=canvas.width/DPR;
    const baseLA=140+Math.abs(player.vx)*0.35+(player.onGround?0:80);
    const maxLA=(player.onGround?viewW*(0.18+lookFactor):viewW*(0.24+lookFactor));
    let targetLA=baseLA*(player.facing>=0?1:-1);
    targetLA=Math.max(-maxLA,Math.min(maxLA,targetLA));
    lookAhead+=(targetLA-lookAhead)*Math.min(1,dt*7);
    camX+=((player.x+lookAhead)-camX)*Math.min(1,dt*7);
    camY+=((player.y-80)-camY)*Math.min(1,dt*7);

    render(L);
    requestAnimationFrame(step);
  }

  // Background animation for menu (neon grid shimmer)
  function renderMenuBackground(now){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const t=now/1000;
    const s=34*DPR;
    ctx.globalAlpha=.1;
    ctx.strokeStyle='#38d9ff';
    ctx.beginPath();
    for(let x=((t*20)%s);x<canvas.width;x+=s){ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);}
    for(let y=((t*12)%s);y<canvas.height;y+=s){ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);}
    ctx.stroke();
    ctx.globalAlpha=1;
    // Soft glow pulse center
    const g=ctx.createRadialGradient(canvas.width/2,canvas.height*0.6,10,canvas.width/2,canvas.height*0.6,Math.max(canvas.width,canvas.height)*0.7);
    g.addColorStop(0,'#0b1f2eaa'); g.addColorStop(1,'#00000000');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // ===== Render (unchanged except visibility tweaks) =====
  function glowRect(x,y,w,h,c,a){
    ctx.globalAlpha=a; ctx.fillStyle=c; ctx.fillRect(x,y,w,h);
    const g=ctx.createRadialGradient(x+w/2,y+h/2,Math.min(w,h)/4,x+w/2,y+h/2,Math.max(w,h));
    g.addColorStop(0,c+'cc'); g.addColorStop(1,c+'00');
    ctx.fillStyle=g; ctx.fillRect(x-h,y-h,w+2*h,h+2*h); ctx.globalAlpha=1;
  }
  function drawSlope(s,c){
    const steps=10;
    for(let i=0;i<steps;i++){
      const t0=i/steps,t1=(i+1)/steps;
      const x0=s.x1+(s.x2-s.x1)*t0, y0=s.y1+(s.y2-s.y1)*t0;
      const x1=s.x1+(s.x2-s.x1)*t1, y1=s.y1+(s.y2-s.y1)*t1;
      glowRect(x0,Math.min(y0,y1)-6,(x1-x0),6,c,1);
    }
  }
  function render(L){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // grid
    const s=32*DPR,gx=-(camX%s),gy=-(camY%s);
    ctx.globalAlpha=.08; ctx.strokeStyle='#0bd7'; ctx.beginPath();
    for(let x=gx;x<canvas.width;x+=s){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
    for(let y=gy;y<canvas.height;y+=s){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
    ctx.stroke(); ctx.globalAlpha=1;

    const viewX=Math.floor(camX-canvas.width/(2*DPR));
    const viewY=Math.floor(camY-canvas.height/(2*DPR));
    ctx.save(); ctx.translate(-viewX,-viewY);

    for(const p of L.pads){
      if(p.t==='rect') glowRect(p.x,p.y,p.w,p.h,'#39d2ff',1);
      else if(p.t==='slope') drawSlope(p,'#39d2ff');
      else if(p.t==='crumble'){
        if(!p.active){ glowRect(p.x,p.y,p.w,p.h,'#ffd27f',0.35); }
        else{
          const warn=Math.min(1,p.timer/Math.max(0.0001,p.breakDelay));
          glowRect(p.x,p.y,p.w,p.h,'#ffd27f',0.6+0.2*warn);
          ctx.globalAlpha=0.3+0.3*warn; ctx.fillStyle='#fff4c2'; ctx.fillRect(p.x,p.y,p.w,4); ctx.globalAlpha=1;
        }
      }
    }
    if(L.plats){ for(const m of L.plats){ glowRect(m.x,m.y,m.w,m.h,'#8ee3ff',.95); } }

    for(const h of L.hz){
      if(h.t==='spike'){
        ctx.fillStyle='#39d2ff'; const baseY=h.y,triW=h.w/3;
        for(let i=0;i<3;i++){ const x0=h.x+i*triW,x1=x0+triW/2,x2=x0+triW;
          ctx.beginPath(); ctx.moveTo(x0,baseY); ctx.lineTo(x2,baseY); ctx.lineTo(x1,baseY-h.h); ctx.closePath(); ctx.fill(); }
      }else if(h.t==='laser'){
        const ox=(h.axis==='x')?(h.offset||0):0, oy=(h.axis==='y')?(h.offset||0):0;
        glowRect(h.x+ox,h.y+oy,h.w,h.h,'#ff6fa6',.9);
      }
    }

    for(const e of L.en){ glowRect(e.x,e.y,e.w,e.h,'#ffe066',.95); }

    const g=L.goal; const t=performance.now()/1000;
    const cx=g.x+g.w/2, cy=g.y+g.h/2;
    glowRect(g.x,g.y,g.w,g.h,'#9ffff0',1);
    ctx.save(); ctx.translate(cx,cy); ctx.rotate(t*.9);
    ctx.globalAlpha=.95; ctx.strokeStyle='#c9fff7'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.arc(0,0,56+12*Math.sin(t*3.2),0,Math.PI*2); ctx.stroke(); ctx.restore();
    glowRect(cx-(14+6*Math.sin(t*5))/2, cy-260, 14+6*Math.sin(t*5), 520, '#c9fff7', .42);

    glowRect(player.x,player.y,player.w,player.h, dashCooldown>0?'#ff6fa6':'#7fffd4',1);

    ctx.restore();
  }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
